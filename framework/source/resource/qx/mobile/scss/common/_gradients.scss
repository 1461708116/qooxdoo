
/**
* Creates a plain-colored, a linear gradient or a radial gradient background, 
* based on the first keyword of the $values list.
*
* If the first value is a color (or "transparent"), the mixin creates a plain colored background with it.
* If the keyword is "linear" is passes all further list-items to the mxins "linear-gradient".
* If the keyword is "radial" it passes all further list-items to the mixins "radial-gradient".
*/
@mixin background($values) {
  $pos-type: type-of(nth($values, 1));
  $first-value: nth($values, 1);

  @if ($pos-type == color) or ($first-value == "transparent")  {
    background-color: $values;
  } @else {
    $gradient-values: ();
    @for $i from 2 through length($values) {
      $gradient-values: append($gradient-values, nth($values, $i));
    }

    @if ($first-value == "linear") {
      @include linear-gradient($gradient-values...);
    } @else if($first-value == "radial") {
      @include radial-gradient($gradient-values...);
    }
  }
}

/*
* See documentation:
* http://bourbon.io/docs/#linear-gradient
*
* https://github.com/thoughtbot/bourbon/blob/master/app/assets/stylesheets/css3/_linear-gradient.scss
*/
@mixin linear-gradient($pos, $G1, $G2: null,
                       $G3: null, $G4: null,
                       $G5: null, $G6: null,
                       $G7: null, $G8: null,
                       $G9: null, $G10: null,
                       $fallback: null) {

  // Detect what type of value exists in $pos
  $pos-type: type-of(nth($pos, 1));
  $pos-spec: null;
  $pos-degree: null;

  // If $pos is missing from mixin, reassign vars and add default position
  @if ($pos-type == color) or (nth($pos, 1) == "transparent")  {
    $G10: $G9; $G9: $G8; $G8: $G7; $G7: $G6; $G6: $G5;
     $G5: $G4; $G4: $G3; $G3: $G2; $G2: $G1; $G1: $pos;
     $pos: null;
  }

  @if $pos {
    $positions: _linear-positions-parser($pos);
    $pos-degree: nth($positions, 1);
    $pos-spec:   nth($positions, 2);
  }

  $full: $G1, $G2, $G3, $G4, $G5, $G6, $G7, $G8, $G9, $G10;

  // Set $G1 as the default fallback color
  $fallback-color: nth($G1, 1);

  // If $fallback is a color use that color as the fallback color
  @if (type-of($fallback) == color) or ($fallback == "transparent") {
    $fallback-color: $fallback;
  }

  background-color: $fallback-color;
  background-image: -webkit-linear-gradient($pos-degree $full);
  background-image: -moz-linear-gradient($pos-degree $full);
  background-image: -ms-linear-gradient($pos-degree $full);
  background-image: unquote(_webkit-gradient($full, $pos));
  background-image: unquote("linear-gradient(#{$pos-spec}#{$full})");
}

/**
* This function creates a linear-gradient string for the old webkit syntax, based 
* on parametes $values. 
*
* The parameter $direction is assumed be one of these values:
* ["to left","to right","to top","to bottom","45deg","-45deg"]
*
* If no direction is passed, or an invalid value occurs, the default gradient is created
* from top to bottom direction.
* 
* For the old webkit gradient syntax ("-webkit-gradient"), please have a look at:
* https://www.webkit.org/blog/175/introducing-css-gradients/
* 
*/
@function _webkit-gradient($values, $direction: null) {
  $last:  length($values);

  // Detect $values length, because it might contain null values.
  @for $i from 1 through length($values) {
    @if(nth($values, $i) != null) {
      $last: $i;
    }
  } 

  $i:1;
  $stops: "";

  @each $value in $values {
    @if($value != null) {
      
      $current: nth($values, $i);
      $next: nth($values, $i + 1);

      // If no position is passed inside color-stop, it calculates the position in percent.
      $pos: ($i - 1)*(1/($last - 1));

      // Separator between color-stops.
      $separator: " ";
      @if($i > 1) {
        $separator:",";
      }

      $color: "";
      @if(length($current) > 1) {
        $pos: nth($current, 2);
        $color: nth($current, 1);
      } @else {
        $color: $current;
      }

      $stops: $stops + $separator + "color-stop("+$pos+","+$color+")";

      $i: $i +1;
    }
  }

  $point: "center top,center bottom";
  @if($direction != null) {
    $direction: ""+$direction;
    @if(""+$direction == "to left") {
      $point: "right center,left center";
    } @else if(""+$direction == "to right") {
      $point: "left center, right center";
    } @else if(""+$direction == "to top") {
      $point: "center bottom,center top";
    } @else if(""+$direction == "to bottom") {
      $point: "center top,center bottom";
    } @else if(""+$direction == "45deg") {
      $point: "0% 100%, 100% 0%";
    } @else if(""+$direction == "-45deg") {
      $point: "0% 0%, 100% 100%";
    }
  }

  @return "-webkit-gradient(linear, #{$point}, #{$stops})";
}


/**
* https://github.com/thoughtbot/bourbon/blob/master/app/assets/stylesheets/helpers/_linear-positions-parser.scss
*/ 
@function _linear-positions-parser($pos) {
  $type: type-of(nth($pos, 1));
  $spec: null;
  $degree: null;
  $side: null;
  $corner: null;
  $length: length($pos);
  // Parse Side and corner positions
  @if ($length > 1) {
    @if nth($pos, 1) == "to" { // Newer syntax
      $side: nth($pos, 2);

      @if $length == 2 { // eg. to top
        // Swap for backwards compatability
        $degree: _position-flipper(nth($pos, 2));
      }
      @else if $length == 3 { // eg. to top left
        $corner: nth($pos, 3);
      }
    }
    @else if $length == 2 { // Older syntax ("top left")
      $side: _position-flipper(nth($pos, 1));
      $corner: _position-flipper(nth($pos, 2));
    }

    @if ("#{$side} #{$corner}" == "left top") or ("#{$side} #{$corner}" == "top left") {
      $degree: _position-flipper(#{$side}) _position-flipper(#{$corner});
    }
    @else if ("#{$side} #{$corner}" == "right top") or ("#{$side} #{$corner}" == "top right") {
      $degree: _position-flipper(#{$side}) _position-flipper(#{$corner});
    }
    @else if ("#{$side} #{$corner}" == "right bottom") or ("#{$side} #{$corner}" == "bottom right") {
      $degree: _position-flipper(#{$side}) _position-flipper(#{$corner});
    }
    @else if ("#{$side} #{$corner}" == "left bottom") or ("#{$side} #{$corner}" == "bottom left") {
      $degree: _position-flipper(#{$side}) _position-flipper(#{$corner});
    }
    $spec: to $side $corner;
  }
  @else if $length == 1 {
    // Swap for backwards compatability
    @if $type == string {
      $degree: $pos;
      $spec: to _position-flipper($pos);
    }
    @else {
      $degree: -270 - $pos; //rotate the gradient opposite from spec
      $spec: $pos;
    }
  }
  $degree: unquote($degree + ",");
  $spec:   unquote($spec + ",");
  @return $degree $spec;
}

@function _position-flipper($pos) {
 @return if($pos == left, right, null)
         if($pos == right, left, null)
         if($pos == top, bottom, null)
         if($pos == bottom, top, null);
}

/*
* See documentation:
* http://bourbon.io/docs/#radial-gradient
*
* Requires Sass 3.1+
*
* https://github.com/thoughtbot/bourbon/blob/master/app/assets/stylesheets/css3/_radial-gradient.scss
*/
@mixin radial-gradient($G1,        $G2,
                       $G3: null, $G4: null,
                       $G5: null, $G6: null,
                       $G7: null, $G8: null,
                       $G9: null, $G10: null,
                       $pos: null,
                       $shape-size: null,
                       $fallback: null) {

  $data: _radial-arg-parser($G1, $G2, $pos, $shape-size);
  $G1:  nth($data, 1);
  $G2:  nth($data, 2);
  $pos: nth($data, 3);
  $shape-size: nth($data, 4);

  $full: $G1, $G2, $G3, $G4, $G5, $G6, $G7, $G8, $G9, $G10;

  // Strip deprecated cover/contain for spec
  $shape-size-spec: _shape-size-stripper($shape-size);

  // Set $G1 as the default fallback color
  $first-color: nth($full, 1);
  $fallback-color: nth($first-color, 1);

  @if (type-of($fallback) == color) or ($fallback == "transparent") {
    $fallback-color: $fallback;
  }

  // Add Commas and spaces
  $shape-size: if($shape-size, '#{$shape-size}, ', null);
  $pos:        if($pos, '#{$pos}, ', null);
  $pos-spec:   if($pos, 'at #{$pos}', null);
  $shape-size-spec: if(($shape-size-spec != ' ') and ($pos == null), '#{$shape-size-spec}, ', '#{$shape-size-spec} ');

  background-color: $fallback-color;
  background-image: -webkit-radial-gradient(unquote(#{$pos}#{$shape-size}#{$full}));
  background-image: -moz-radial-gradient(unquote(#{$pos}#{$shape-size}#{$full}));
  background-image: -ms-radial-gradient(unquote(#{$pos}#{$shape-size}#{$full}));
  background-image: unquote("radial-gradient(#{$shape-size-spec}#{$pos-spec}#{$full})");
}


/*
* https://github.com/thoughtbot/bourbon/blob/master/app/assets/stylesheets/helpers/_radial-arg-parser.scss
*/
@function _radial-arg-parser($G1, $G2, $pos, $shape-size) {
  @each $value in $G1, $G2 {
    $first-val: nth($value, 1);
    $pos-type:  type-of($first-val);
    $spec-at-index: null;

    // Determine if spec was passed to mixin
    @if type-of($value) == list {
      $spec-at-index: if(index($value, at), index($value, at), false);
    }
    @if $spec-at-index {
      @if $spec-at-index > 1 {
        @for $i from 1 through ($spec-at-index - 1) {
          $shape-size: $shape-size nth($value, $i);
        }
        @for $i from ($spec-at-index + 1) through length($value) {
          $pos: $pos nth($value, $i);
        }
      }
      @else if $spec-at-index == 1 {
        @for $i from ($spec-at-index + 1) through length($value) {
          $pos: $pos nth($value, $i);
        }
      }
      $G1: null;
    }

    // If not spec calculate correct values
    @else {
      @if ($pos-type != color) or ($first-val != "transparent") {
        @if ($pos-type == number)
        or ($first-val == "center")
        or ($first-val == "top")
        or ($first-val == "right")
        or ($first-val == "bottom")
        or ($first-val == "left") {

          $pos: $value;

          @if $pos == $G1 {
            $G1: null;
          }
        }

        @else if
           ($first-val == "ellipse")
        or ($first-val == "circle")
        or ($first-val == "closest-side")
        or ($first-val == "closest-corner")
        or ($first-val == "farthest-side")
        or ($first-val == "farthest-corner")
        or ($first-val == "contain")
        or ($first-val == "cover") {

          $shape-size: $value;

          @if $value == $G1 {
            $G1: null;
          }

          @else if $value == $G2 {
            $G2: null;
          }
        }
      }
    }
  }
  @return $G1, $G2, $pos, $shape-size;
}